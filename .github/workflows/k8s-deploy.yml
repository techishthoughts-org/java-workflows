# .github/workflows/k8s-deploy.yml
# Purpose: Kubernetes deployment workflow v3.0.0 for cloud-native deployments
# Version: 3.0.0
# Supports: EKS (AWS), GKE (Google), AKS (Azure), self-hosted K8s
#
# Inputs:
#   cluster-provider: Kubernetes provider - 'eks', 'gke', 'aks', 'custom' (default: 'custom')
#   cluster-name: Kubernetes cluster name
#   namespace: Kubernetes namespace (default: 'default')
#   deployment-name: Name of the deployment
#   image-name: Docker image name (with tag)
#   kubectl-version: kubectl version (default: 'latest')
#   dry-run: Perform dry-run without applying (default: false)
#   wait-for-rollout: Wait for deployment rollout (default: true)
#
# Usage:
#   jobs:
#     deploy:
#       uses: org/workflows/.github/workflows/k8s-deploy.yml@v3
#       with:
#         cluster-provider: 'eks'
#         cluster-name: 'my-cluster'
#         namespace: 'production'
#         deployment-name: 'myapp'
#         image-name: 'myapp:v1.0.0'

name: â˜¸ï¸ Kubernetes Deployment v3.0.0

on:
  workflow_call:
    inputs:
      cluster-provider:
        required: false
        type: string
        default: 'custom'
      cluster-name:
        required: true
        type: string
      namespace:
        required: false
        type: string
        default: 'default'
      deployment-name:
        required: true
        type: string
      image-name:
        required: true
        type: string
      kubectl-version:
        required: false
        type: string
        default: 'latest'
      dry-run:
        required: false
        type: boolean
        default: false
      wait-for-rollout:
        required: false
        type: boolean
        default: true
      replicas:
        required: false
        type: number
        default: 3
    outputs:
      deployment-status:
        description: "Deployment status"
        value: ${{ jobs.deploy.outputs.status }}
      rollout-status:
        description: "Rollout status"
        value: ${{ jobs.deploy.outputs.rollout-status }}
    secrets:
      KUBECONFIG:
        description: "Kubernetes config (for custom clusters)"
        required: false
      AWS_ACCESS_KEY_ID:
        description: "AWS access key (for EKS)"
        required: false
      AWS_SECRET_ACCESS_KEY:
        description: "AWS secret key (for EKS)"
        required: false
      GCP_SA_KEY:
        description: "GCP service account key (for GKE)"
        required: false
      AZURE_CREDENTIALS:
        description: "Azure credentials (for AKS)"
        required: false

jobs:
  deploy:
    name: ðŸš€ Deploy to ${{ inputs.cluster-provider }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      status: ${{ steps.deploy.outputs.status }}
      rollout-status: ${{ steps.rollout.outputs.status }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ inputs.kubectl-version }}

      - name: â˜ï¸ Configure AWS EKS
        if: inputs.cluster-provider == 'eks'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION || 'us-east-1' }}

      - name: ðŸ” Get EKS kubeconfig
        if: inputs.cluster-provider == 'eks'
        shell: bash
        run: |
          aws eks update-kubeconfig --name ${{ inputs.cluster-name }} --region ${AWS_REGION:-us-east-1}
          kubectl config current-context

      - name: â˜ï¸ Configure Google GKE
        if: inputs.cluster-provider == 'gke'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ðŸ” Get GKE kubeconfig
        if: inputs.cluster-provider == 'gke'
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ inputs.cluster-name }}
          location: ${{ env.GCP_ZONE || 'us-central1' }}

      - name: â˜ï¸ Configure Azure AKS
        if: inputs.cluster-provider == 'aks'
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ðŸ” Get AKS kubeconfig
        if: inputs.cluster-provider == 'aks'
        uses: azure/aks-set-context@v3
        with:
          cluster-name: ${{ inputs.cluster-name }}
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}

      - name: ðŸ” Setup Custom Kubeconfig
        if: inputs.cluster-provider == 'custom'
        shell: bash
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: âœ… Verify Connection
        shell: bash
        run: |
          echo "âœ… Testing Kubernetes connection..."
          kubectl cluster-info
          kubectl get nodes

      - name: ðŸ“‹ Create/Update Namespace
        shell: bash
        run: |
          if ! kubectl get namespace ${{ inputs.namespace }} > /dev/null 2>&1; then
            echo "ðŸ“‹ Creating namespace ${{ inputs.namespace }}..."
            kubectl create namespace ${{ inputs.namespace }}
          else
            echo "âœ… Namespace ${{ inputs.namespace }} already exists"
          fi

      - name: ðŸš€ Deploy Application
        id: deploy
        shell: bash
        run: |
          DRY_RUN_FLAG=""
          if [[ "${{ inputs.dry-run }}" == "true" ]]; then
            DRY_RUN_FLAG="--dry-run=client"
            echo "ðŸ§ª DRY RUN MODE - No changes will be applied"
          fi

          # Create deployment YAML
          cat > deployment.yaml <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ inputs.deployment-name }}
            namespace: ${{ inputs.namespace }}
            labels:
              app: ${{ inputs.deployment-name }}
              version: v3
          spec:
            replicas: ${{ inputs.replicas }}
            selector:
              matchLabels:
                app: ${{ inputs.deployment-name }}
            template:
              metadata:
                labels:
                  app: ${{ inputs.deployment-name }}
                  version: v3
              spec:
                containers:
                - name: ${{ inputs.deployment-name }}
                  image: ${{ inputs.image-name }}
                  ports:
                  - containerPort: 8080
                    protocol: TCP
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: 8080
                    initialDelaySeconds: 5
                    periodSeconds: 5
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ inputs.deployment-name }}-service
            namespace: ${{ inputs.namespace }}
          spec:
            selector:
              app: ${{ inputs.deployment-name }}
            ports:
            - protocol: TCP
              port: 80
              targetPort: 8080
            type: LoadBalancer
          EOF

          echo "ðŸš€ Applying deployment..."
          kubectl apply -f deployment.yaml -n ${{ inputs.namespace }} $DRY_RUN_FLAG

          if [[ "${{ inputs.dry-run }}" != "true" ]]; then
            echo "status=deployed" >> $GITHUB_OUTPUT
          else
            echo "status=dry-run" >> $GITHUB_OUTPUT
          fi

      - name: â³ Wait for Rollout
        id: rollout
        if: inputs.wait-for-rollout == true && inputs.dry-run == false
        shell: bash
        run: |
          echo "â³ Waiting for rollout to complete..."
          kubectl rollout status deployment/${{ inputs.deployment-name }} -n ${{ inputs.namespace }} --timeout=5m

          if [ $? -eq 0 ]; then
            echo "âœ… Rollout completed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Rollout failed or timed out"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: ðŸ“Š Deployment Info
        if: inputs.dry-run == false
        shell: bash
        run: |
          echo "ðŸ“Š Deployment Information:"
          kubectl get deployment ${{ inputs.deployment-name }} -n ${{ inputs.namespace }}
          kubectl get pods -n ${{ inputs.namespace }} -l app=${{ inputs.deployment-name }}
          kubectl get service ${{ inputs.deployment-name }}-service -n ${{ inputs.namespace }}

      - name: ðŸ“ Summary
        if: always()
        shell: bash
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ### â˜¸ï¸ Kubernetes Deployment Summary

          | Setting | Value |
          |---------|-------|
          | **Cluster Provider** | ${{ inputs.cluster-provider }} |
          | **Cluster** | ${{ inputs.cluster-name }} |
          | **Namespace** | ${{ inputs.namespace }} |
          | **Deployment** | ${{ inputs.deployment-name }} |
          | **Image** | ${{ inputs.image-name }} |
          | **Replicas** | ${{ inputs.replicas }} |
          | **Dry Run** | ${{ inputs.dry-run }} |
          | **Status** | ${{ steps.deploy.outputs.status }} |

          EOF

          if [[ "${{ inputs.dry-run }}" == "false" ]]; then
            echo "**ðŸ”— Access:** Check service endpoint for public access" >> $GITHUB_STEP_SUMMARY
          fi
